"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const fs_1 = require("fs");

const pg_connection_string_1 = require("@databases/pg-connection-string");

const pg_data_type_id_1 = require("@databases/pg-data-type-id");

exports.DataTypeID = pg_data_type_id_1.default;

const pg_errors_1 = require("@databases/pg-errors");

exports.isSQLError = pg_errors_1.isSQLError;
exports.SQLErrorCode = pg_errors_1.SQLErrorCode;

const sql_1 = require("@databases/sql");

exports.sql = sql_1.default;
exports.isSqlQuery = sql_1.isSqlQuery;

const pg_config_1 = require("@databases/pg-config");

const ConnectionPool_1 = require("./ConnectionPool");

const IsolationLevel_1 = require("./types/IsolationLevel");

exports.IsolationLevel = IsolationLevel_1.default;

const Queryable_1 = require("./types/Queryable");

exports.QueryableType = Queryable_1.QueryableType;
exports.isTransaction = Queryable_1.isTransaction;
exports.isConnection = Queryable_1.isConnection;
exports.isConnectionPool = Queryable_1.isConnectionPool;

const TypeOverrides_1 = require("./TypeOverrides");

const {
  connectionStringEnvironmentVariable
} = pg_config_1.getPgConfigSync();

function createConnectionPool(connectionConfig = process.env[connectionStringEnvironmentVariable]) {
  if (!connectionConfig) {
    throw new Error('You must provide a connection string for @databases/pg. You can ' + 'either pass one directly to the createConnection call or set ' + `the ${connectionStringEnvironmentVariable} environment variable.`);
  }

  const {
    connectionString = process.env[connectionStringEnvironmentVariable]
  } = typeof connectionConfig === 'object' ? connectionConfig : {
    connectionString: connectionConfig
  };
  const parsedConnectionString = pg_connection_string_1.default(connectionString || undefined);
  const {
    user = parsedConnectionString.user,
    password = parsedConnectionString.password,
    host = parsedConnectionString.host,
    database = parsedConnectionString.dbname,
    port = parsedConnectionString.port,
    connectionTimeoutMilliseconds = 10000,
    idleTimeoutMilliseconds = 30000,
    poolSize = 10,
    statementTimeoutMilliseconds = 0,
    queryTimeoutMilliseconds = 0,
    idleInTransactionSessionTimeoutMilliseconds = 0,
    applicationName = parsedConnectionString.application_name,
    keepAlive = false,
    keepAliveInitialDelayMilliseconds = 0,
    maxUses = Infinity,
    bigIntMode = null,
    // tslint:disable-next-line:deprecation
    bigIntAsString = false,
    schema = null,
    types: typeOverrides = null,
    onError = err => {
      // It's common for connections to be terminated "unexpectedly"
      // If it happens on a connection that is actively in use, you'll get the error
      // anyway when you attempt to query it. If it happens on a connection that is
      // idle in the pool, a fresh connection will be allocated without you needing
      // to do anything.
      if (!/connection\s*terminated\s*unexpectedly/.test(err.message)) {
        console.warn(`Error in Postgres ConnectionPool: ${err.message}`);
      }
    }
  } = typeof connectionConfig === 'object' ? connectionConfig : {};

  if (bigIntAsString) {
    console.warn('bigIntAsString is deprecated and will be removed in the next major version of @databases/pg, use `bigIntMode: "string"` instead');
  } else if (bigIntMode === null) {
    console.warn('bigIntMode currently deafults to "number" but will default to "bigint" in the next major version of @databases/pg. Set it explicitly to disable this warning.');
  }

  const types = new TypeOverrides_1.default({
    bigIntMode: bigIntMode !== null && bigIntMode !== void 0 ? bigIntMode : bigIntAsString ? 'string' : 'number',
    overrides: typeOverrides !== null && typeOverrides !== void 0 ? typeOverrides : undefined
  });
  const sslConfig = getSSLConfig(typeof connectionConfig === 'object' ? connectionConfig : {}, parsedConnectionString);
  const hostList = Array.isArray(host) ? host : [host];
  const portList = Array.isArray(port) ? port : [port];

  if (portList.length > 1 && hostList.length !== portList.length) {
    throw new Error('If you provide more than port, you must provide exactly the same number of hosts and port');
  }

  const pgOptions = {
    user,
    password,
    database,
    connectionTimeoutMillis: connectionTimeoutMilliseconds,
    idleTimeoutMillis: idleTimeoutMilliseconds,
    max: poolSize,
    ...(statementTimeoutMilliseconds ? {
      statement_timeout: statementTimeoutMilliseconds
    } : {}),
    ...(queryTimeoutMilliseconds ? {
      query_timeout: queryTimeoutMilliseconds
    } : {}),
    ...(idleInTransactionSessionTimeoutMilliseconds ? {
      idle_in_transaction_session_timeout: idleInTransactionSessionTimeoutMilliseconds
    } : {}),
    application_name: applicationName || (typeof connectionConfig === 'object' ? connectionConfig : {}).fallbackApplicationName || parsedConnectionString.fallback_application_name,
    keepAlive,
    keepAliveInitialDelayMillis: keepAliveInitialDelayMilliseconds,
    maxUses,
    types
  };
  return new ConnectionPool_1.default(pgOptions, {
    hosts: (hostList.length === 0 ? ['localhost'] : hostList).map((host, i) => {
      const port = portList.length === 0 ? undefined : portList.length === 1 ? portList[0] : portList[i];
      return {
        host,
        port: port !== null && port !== void 0 ? port : undefined
      };
    }),
    schema: schema !== null && schema !== void 0 ? schema : undefined,
    ssl: sslConfig,
    handlers: {
      onError
    }
  });
}

exports.default = createConnectionPool;

function getSSLConfig(config, parsedConnectionString) {
  if (config.ssl === false || config.ssl === 'disable' || !config.ssl && parsedConnectionString.sslmode === 'disable') {
    return null;
  }

  if (config.ssl && typeof config.ssl === 'object') {
    return {
      allowFallback: false,
      ssl: config.ssl
    };
  }

  const ssl = {};

  if (parsedConnectionString.sslcert) {
    ssl.cert = fs_1.readFileSync(parsedConnectionString.sslcert, 'utf8');
  }

  if (parsedConnectionString.sslkey) {
    ssl.key = fs_1.readFileSync(parsedConnectionString.sslkey, 'utf8');
  }

  if (parsedConnectionString.sslrootcert) {
    ssl.ca = fs_1.readFileSync(parsedConnectionString.sslrootcert, 'utf8');
  }

  if (config.ssl === 'no-verify' || !config.ssl && parsedConnectionString.sslmode === 'no-verify' || !(parsedConnectionString.sslcert || parsedConnectionString.sslkey || parsedConnectionString.sslrootcert)) {
    ssl.rejectUnauthorized = false;
  }

  const mode = config.ssl || parsedConnectionString.sslmode;

  if (mode === 'prefer' || mode === undefined) {
    ssl.rejectUnauthorized = false;
    return {
      allowFallback: true,
      ssl
    };
  } else {
    return {
      allowFallback: false,
      ssl
    };
  }
}

module.exports = Object.assign(createConnectionPool, {
  default: createConnectionPool,
  sql: sql_1.default,
  isSqlQuery: sql_1.isSqlQuery,
  isSQLError: pg_errors_1.isSQLError,
  SQLErrorCode: pg_errors_1.SQLErrorCode,
  DataTypeID: pg_data_type_id_1.default,
  IsolationLevel: IsolationLevel_1.default,
  QueryableType: Queryable_1.QueryableType,
  isTransaction: Queryable_1.isTransaction,
  isConnection: Queryable_1.isConnection,
  isConnectionPool: Queryable_1.isConnectionPool
}); // interface UndocumentedPgOptions {
//   /**
//    * Use binary mode for pg communication,
//    * defaults to false
//    */
//   binary: boolean;
//   /**
//    * Override the "Promise" used within pg
//    */
//   Promise: typeof Promise;
//   /**
//    * Passed to `new ConnectionParameters(...)` and used in Client.getStartupConf()
//    * Defaults to fallback_application_name
//    */
//   application_name: string;
//   /**
//    * Passed to `new ConnectionParameters(...)` and used in Client.getStartupConf()
//    */
//   fallback_application_name: string;
//   /**
//    * Passed to `new ConnectionParameters(...)` and used in Client.getStartupConf()
//    *
//    * This changes the protocol that's used, which would almost certainly just break the library
//    */
//   replication: string;
//   /**
//    * Passed to `new ConnectionParameters(...)` and used in Client.getStartupConf()
//    *
//    * There's probably always a better option for how to set these options
//    */
//   options: string;
//   /**
//    * Passed to `new TypeOverrides(...)`
//    */
//   types: unknown;
//   /**
//    * Passed to `new Connection(...)`
//    */
//   stream: unknown;
//   /**
//    * Passed to `new Connection(...)` as "encoding",
//    * defaults to 'utf8'
//    */
//   client_encoding: boolean;
//   /**
//    * Passed to `new Connection(...)`,
//    * defaults to false
//    */
//   keepAlive: boolean;
//   /**
//    * Passed to `new Connection(...)`,
//    * defaults to 0
//    */
//   keepAliveInitialDelayMillis: number;
//   /**
//    * Passed to `new Pool(...)`,
//    * defaults to Infinity
//    */
//   maxUses: number;
//   /**
//    * Passed to `new Pool(...)`,
//    * defaults to Infinity
//    */
//   log: () => void;
//   /**
//    * Passed to `new Pool(...)`,
//    * Called on newly acquired clients to test that they are working before adding them to the pool.
//    */
//   verify: (client: Client, cb: (err?: Error | null) => void) => void;
// }