"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const throat_1 = require("throat");

const sql_1 = require("@databases/sql");

const escape_identifier_1 = require("@databases/escape-identifier");

const Connection_1 = require("./Connection");

const stream_1 = require("stream");

const Queryable_1 = require("./types/Queryable");

const TypeOverrides_1 = require("./TypeOverrides");

const {
  Pool
} = require('pg');

const sslProperty = Symbol('_ssl');

class ConnectionPool {
  constructor(options, {
    schema,
    hosts,
    ssl,
    handlers
  }) {
    this.type = Queryable_1.QueryableType.ConnectionPool;
    this.sql = sql_1.default;
    this._hadSuccessfulConnection = false;
    this._disposed = false;
    this._repairConnectionPool = throat_1.default(1, async () => {
      var _a, _b;

      if (this._hadSuccessfulConnection) return null;
      const start = Date.now();
      let error;
      let attemptCount = 0;

      do {
        attemptCount++;

        if (attemptCount) {
          await new Promise(resolve => setTimeout(resolve, attemptCount * 100));
        }

        for (const {
          host,
          port
        } of this._config.hosts) {
          this._pool.options.host = host;
          this._pool.options.port = port;
          this._pool.options.ssl = (_a = this._config[sslProperty]) === null || _a === void 0 ? void 0 : _a.ssl;

          try {
            const connection = await this._pool.connect();
            this._hadSuccessfulConnection = true;
            return connection;
          } catch (ex) {
            error = ex;

            if (((_b = this._config[sslProperty]) === null || _b === void 0 ? void 0 : _b.allowFallback) && /the server does not support ssl connections/i.test(error.message)) {
              // The Postgres server does not support SSL and our sslmode is "prefer"
              // (which is the default). In this case we immediately retry without
              // ssl.
              try {
                this._pool.options.ssl = false;
                const connection = await this._pool.connect();
                this._hadSuccessfulConnection = true;
                return connection;
              } catch (ex) {
                error = ex;
              }
            }
          }
        } // If you try to connect very quickly after postgres boots (e.g. intesting environments)
        // you can get an error of "Connection terminated unexpectedly". For this reason, we retry
        // all possible connections for up to 2 seconds

      } while (Date.now() - start < 2000);

      throw error;
    });
    this.parseComposite = TypeOverrides_1.parseComposite;
    this.parseArray = TypeOverrides_1.parseArray;
    this._config = {
      options,
      hosts,
      [sslProperty]: ssl
    };
    this._pool = new Pool({ ...options,
      ssl: ssl === null || ssl === void 0 ? void 0 : ssl.ssl,
      ...hosts[0]
    });
    this._schema = schema;

    this._pool.on('error', err => handlers.onError(err));

    this._preparingOverrides = this._withTypeResolver(getTypeID => this._pool.options.types.prepareOverrides(getTypeID));

    this._preparingOverrides.catch(_ex => {// this error will be surfaced later, we do not want it to be treated
      // as an unhandled rejection yet
    });
  }

  _throwIfDisposed() {
    if (this._disposed) {
      throw new Error('You cannot run any operations on a connection pool after it has been disposed.');
    }
  }

  async _getClient() {
    this._throwIfDisposed();

    let client;

    if (!this._hadSuccessfulConnection) {
      client = await this._repairConnectionPool();
    }

    if (!client) {
      try {
        client = await this._pool.connect();
      } catch (ex) {
        this._hadSuccessfulConnection = false;
        client = await this._repairConnectionPool();
      }
    }

    if (!client) {
      client = await this._pool.connect();
    }

    if (!client._atdatabases_has_set_schema && this._schema) {
      if (typeof this._schema === 'string') {
        await client.query(`SET search_path TO ${escape_identifier_1.escapePostgresIdentifier(this._schema)}`);
      } else if (Array.isArray(this._schema)) {
        await client.query(`SET search_path TO ${this._schema.map(s => escape_identifier_1.escapePostgresIdentifier(s)).join(', ')}`);
      }

      client._atdatabases_has_set_schema = true;
    }

    return client;
  }

  async _withTypeResolver(fn) {
    const client = await this._getClient();

    try {
      const result = await fn(async typeName => {
        const ts = typeName.split('.');
        let results;

        if (ts.length === 1) {
          results = await this.query(sql_1.default`
            SELECT
              ty.oid as "typeID",
              ns.nspname AS "schemaName"
            FROM pg_catalog.pg_type ty
            INNER JOIN pg_catalog.pg_namespace ns
              ON (ty.typnamespace = ns.oid)
            WHERE lower(ty.typname) = ${typeName.toLowerCase()};
          `);
        } else if (ts.length === 2) {
          results = await this.query(sql_1.default`
            SELECT
              ty.oid as "typeID",
              ns.nspname AS "schemaName"
            FROM pg_catalog.pg_type ty
            INNER JOIN pg_catalog.pg_namespace ns
              ON (ty.typnamespace = ns.oid)
            WHERE lower(ty.typname) = ${ts[1].toLowerCase()} AND lower(ns.nspname) = ${ts[0].toLowerCase()};
          `);
        } else {
          throw new Error('Type Name should only have one "." in it');
        }

        if (results.length === 0) {
          throw new Error('Could not find the type ' + typeName);
        }

        if (results.length > 1) {
          throw new Error('The type name ' + typeName + ' was found in multiple schemas: ' + results.map(r => r.schemaName).join(', '));
        }

        return results[0].typeID;
      });
      client.release();
      return result;
    } catch (ex) {
      client.release(true);
      throw ex;
    }
  }

  async registerTypeParser(type, parser) {
    if (typeof type === 'number') {
      this._pool.options.types.setTypeParser(type, parser);
    } else {
      await this._withTypeResolver(async getTypeID => {
        this._pool.options.types.setTypeParser(await getTypeID(type), parser);
      });
    }

    return parser;
  }

  async getTypeParser(type) {
    if (typeof type === 'number') {
      return this._pool.options.types.getTypeParser(type);
    } else {
      return await this._withTypeResolver(async getTypeID => this._pool.options.types.getTypeParser(await getTypeID(type)));
    }
  }

  async task(fn) {
    await this._preparingOverrides;
    const client = await this._getClient();
    const connection = new Connection_1.default(client);

    try {
      const result = await fn(connection);
      connection.dispose();
      client.release();
      return result;
    } catch (ex) {
      connection.dispose();
      client.release(true);
      throw ex;
    }
  }

  async tx(fn, transactionOptions = {}) {
    this._throwIfDisposed();

    return await this.task(async connection => await connection.tx(fn, transactionOptions));
  }

  async query(query) {
    this._throwIfDisposed();

    if (Array.isArray(query) && query.length === 0) return [];
    return await this.task(async connection => {
      if (Array.isArray(query)) {
        return await connection.query(query);
      } else {
        return await connection.query(query);
      }
    });
  }

  queryNodeStream(query, options = {}) {
    const stream = new stream_1.PassThrough({
      objectMode: true
    });
    Promise.resolve(null).then(async () => {
      await this._preparingOverrides;
      const client = await this._getClient();
      const connection = new Connection_1.default(client);
      const connectionStream = connection.queryNodeStream(query, options);
      connectionStream.pipe(stream);
      connectionStream.on('error', () => {
        client === null || client === void 0 ? void 0 : client.release(true);
        stream.emit('error', stream);
      });
      connectionStream.on('close', () => {
        client === null || client === void 0 ? void 0 : client.release();
        stream.emit('close');
      });
      stream.on('close', () => {
        connectionStream.destroy();
      });
    }).catch(ex => stream.emit('error', ex));
    return stream;
  }

  async *queryStream(query, options = {}) {
    await this._preparingOverrides;
    const client = await this._getClient();
    const connection = new Connection_1.default(client);

    try {
      for await (const row of connection.queryStream(query, options)) {
        yield row;
      }

      connection.dispose();
      client.release();
    } catch (ex) {
      connection.dispose();
      client.release(true);
      throw ex;
    }
  }

  async dispose() {
    if (!this._disposed) {
      this._disposed = true;
      await this._pool.end();
    }
  }

}

exports.default = ConnectionPool;