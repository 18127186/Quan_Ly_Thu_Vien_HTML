"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const pg_data_type_id_1 = require("@databases/pg-data-type-id");

const {
  types
} = require('pg');

function isTypeOverridesMap(value) {
  return value !== null && typeof value === 'object' && typeof value.forEach === 'function';
}

class TypeOverrides {
  constructor(config) {
    this._overrides = {
      text: new Map(),
      binary: new Map()
    };

    if (config.bigIntMode === 'bigint') {
      this._overrides.binary.set(pg_data_type_id_1.default.int8, value => value.readBigInt64BE(0));

      this._overrides.text.set(pg_data_type_id_1.default.int8, value => BigInt(value));
    } else if (config.bigIntMode === 'number') {
      this._overrides.binary.set(pg_data_type_id_1.default.int8, value => parseInt(value.readBigInt64BE(0).toString(10), 10));

      this._overrides.text.set(pg_data_type_id_1.default.int8, value => parseInt(value, 10));
    }

    this._complexOverrides = config.overrides;
  }

  async prepareOverrides(resolveTypeID) {
    let overrides;

    if (typeof this._complexOverrides === 'function') {
      overrides = await this._complexOverrides({
        getTypeParser: (type, ...rest) => {
          if (typeof type === 'number') {
            return this.getTypeParser(type, ...rest);
          } else {
            return resolveTypeID(type).then(id => this.getTypeParser(id, ...rest));
          }
        },
        setTypeParser: (type, ...rest) => {
          if (typeof type === 'number') {
            this.setTypeParser(type, ...rest);
          } else {
            return resolveTypeID(type).then(id => this.setTypeParser(id, ...rest));
          }
        },
        parseComposite,
        parseArray
      });
    } else {
      overrides = this._complexOverrides;
    }

    if (isTypeOverridesMap(overrides)) {
      overrides.forEach((value, key) => {
        if (Array.isArray(value)) {
          this._overrides.text.set(value[0], value[1]);
        } else {
          this._overrides.text.set(key, value);
        }
      });
    } else if (overrides && typeof overrides === 'object') {
      for (const [key, value] of Object.entries(overrides)) {
        if (value) this._overrides.text.set(parseInt(key, 10), value);
      }
    }
  }

  setTypeParser(oid, ...rest) {
    const [a, b] = rest;
    const [format, parseFn] = typeof a === 'function' ? ['text', a] : [a, b];

    this._overrides[format].set(oid, parseFn);
  }

  getTypeParser(oid, format = 'text') {
    var _a;

    return (_a = this._overrides[format].get(oid)) !== null && _a !== void 0 ? _a : types.getTypeParser(oid, format);
  }

}

exports.default = TypeOverrides;
/**
 * Parse a composite value and get a tuple of strings where
 * each string represents one attribute.
 *
 * @param value The raw string.
 */

function parseComposite(value) {
  if (value[0] !== '(') {
    throw new Error('composite values should start with (');
  }

  const values = [];
  let currentValue = '';
  let quoted = false;

  for (let i = 1; i < value.length; i++) {
    if (!quoted && value[i] === ',') {
      values.push(currentValue);
      currentValue = '';
      continue;
    } else if (!quoted && value[i] === ')') {
      values.push(currentValue);
      currentValue = '';

      if (i !== value.length - 1) {
        throw new Error('Got ")" before end of value');
      }

      continue;
    } else if (quoted && value[i] === '"') {
      if (value[i + 1] === '"') {
        // if the next value is also a quote, that means we
        // are looking at an escaped quote. Skip this char
        // and insert the quote
        i++;
      } else {
        quoted = false;
        continue;
      }
    } else if (value[i] === '"') {
      quoted = true;
      continue;
    }

    currentValue += value[i];
  }

  if (currentValue) {
    throw new Error('Got to end of value with no ")"');
  }

  return values;
}

exports.parseComposite = parseComposite;
const parseStringArray = types.getTypeParser(pg_data_type_id_1.default._text);

function parseArray(value, entryParser) {
  if (entryParser) {
    return parseStringArray(value).map(entryParser);
  } else {
    return parseStringArray(value);
  }
}

exports.parseArray = parseArray;