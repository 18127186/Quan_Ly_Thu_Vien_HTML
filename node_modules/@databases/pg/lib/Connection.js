"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const sql_1 = require("@databases/sql");

const pg_errors_1 = require("@databases/pg-errors");

const throat_1 = require("throat");

const Transaction_1 = require("./Transaction");

const transaction_1 = require("./operations/transaction");

const queries_1 = require("./operations/queries");

const queryStream_1 = require("./operations/queryStream");

const Queryable_1 = require("./types/Queryable");

class Connection {
  constructor(client) {
    this.type = Queryable_1.QueryableType.Connection;
    this.sql = sql_1.default;
    this._disposed = false; // TODO: lock with timetout!!

    this._lock = throat_1.default(1);
    this._client = client;
  }

  _throwIfDisposed() {
    if (this._disposed) {
      throw new Error('You cannot run any operations on a connection after it has been returned to the connection pool.');
    }
  }

  async task(fn) {
    return await fn(this);
  }

  async tx(fn, transactionOptions = {}) {
    let retrySerializationFailuresCount = transactionOptions.retrySerializationFailures === true ? 10 : typeof transactionOptions.retrySerializationFailures === 'number' ? transactionOptions.retrySerializationFailures : 0;

    while (true) {
      try {
        return await this._lock(async () => {
          this._throwIfDisposed();

          await transaction_1.beginTransaction(this._client, transactionOptions);
          const transaction = new Transaction_1.default(this._client);

          try {
            const result = await fn(transaction);
            await transaction_1.commitTransaction(this._client);
            transaction.dispose();
            return result;
          } catch (ex) {
            transaction.dispose();
            await transaction_1.rollbackTransaction(this._client);
            throw ex;
          }
        });
      } catch (ex) {
        if (pg_errors_1.isSQLError(ex) && ex.code === pg_errors_1.SQLErrorCode.SERIALIZATION_FAILURE) {
          if (retrySerializationFailuresCount--) {
            continue;
          }
        }

        throw ex;
      }
    }
  }

  async query(query) {
    if (Array.isArray(query) && query.length === 0) return [];
    return await this._lock(async () => {
      this._throwIfDisposed();

      if (Array.isArray(query)) {
        await transaction_1.beginTransaction(this._client, {});

        try {
          const result = await queries_1.executeMultipleStatements(this._client, query);
          await transaction_1.commitTransaction(this._client);
          return result;
        } catch (ex) {
          await transaction_1.rollbackTransaction(this._client);
          throw ex;
        }
      } else {
        return queries_1.executeOneStatement(this._client, query);
      }
    });
  }

  queryNodeStream(query, options = {}) {
    return queryStream_1.queryNodeStream(this._client, query, options);
  }

  queryStream(query, options = {}) {
    return queryStream_1.queryStream(this._client, query, options);
  }

  dispose() {
    this._disposed = true;
  }

}

exports.default = Connection;