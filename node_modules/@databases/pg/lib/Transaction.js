"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const sql_1 = require("@databases/sql");

const throat_1 = require("throat");

const cuid = require("cuid");

const savepoint_1 = require("./operations/savepoint");

const queries_1 = require("./operations/queries");

const queryStream_1 = require("./operations/queryStream");

const Queryable_1 = require("./types/Queryable");

class Transaction {
  constructor(client) {
    this.type = Queryable_1.QueryableType.Transaction;
    this.sql = sql_1.default;
    this._disposed = false; // TODO: lock with timetout!!

    this._lock = throat_1.default(1);
    this._client = client;
  }

  _throwIfDisposed() {
    if (this._disposed) {
      throw new Error('You cannot run any operations on a transaction after it has been committed or rolled back.');
    }
  }

  async task(fn) {
    return await fn(this);
  }

  async tx(fn) {
    return await this._lock(async () => {
      this._throwIfDisposed();

      const savepointName = cuid();
      await savepoint_1.createSavepoint(this._client, savepointName);
      const subTransaction = new Transaction(this._client);

      try {
        const result = await fn(subTransaction);
        await savepoint_1.commitSavepoint(this._client, savepointName);
        subTransaction.dispose();
        return result;
      } catch (ex) {
        subTransaction.dispose();
        await savepoint_1.rollbackSavepoint(this._client, savepointName);
        throw ex;
      }
    });
  }

  async query(query) {
    if (Array.isArray(query) && query.length === 0) return [];
    return await this._lock(async () => {
      this._throwIfDisposed();

      if (Array.isArray(query)) {
        const savepointName = cuid();
        await savepoint_1.createSavepoint(this._client, savepointName);

        try {
          const result = await queries_1.executeMultipleStatements(this._client, query);
          await savepoint_1.commitSavepoint(this._client, savepointName);
          return result;
        } catch (ex) {
          await savepoint_1.rollbackSavepoint(this._client, savepointName);
          throw ex;
        }
      } else {
        return queries_1.executeOneStatement(this._client, query);
      }
    });
  }

  queryNodeStream(query, options = {}) {
    return queryStream_1.queryNodeStream(this._client, query, options);
  }

  queryStream(query, options = {}) {
    return queryStream_1.queryStream(this._client, query, options);
  }

  dispose() {
    this._disposed = true;
  }

}

exports.default = Transaction;