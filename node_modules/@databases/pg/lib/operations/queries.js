"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const escape_identifier_1 = require("@databases/escape-identifier");

const pg_errors_1 = require("@databases/pg-errors");

const split_sql_query_1 = require("@databases/split-sql-query");

const sql_1 = require("@databases/sql");

const {
  codeFrameColumns
} = require('@babel/code-frame');

const pgFormat = {
  escapeIdentifier: str => escape_identifier_1.escapePostgresIdentifier(str),
  formatValue: (value, index) => ({
    placeholder: `$${index + 1}`,
    value
  })
};

async function executeOneStatement(client, query) {
  if (!sql_1.isSqlQuery(query)) {
    throw new Error('Invalid query, you must use @databases/sql to create your queries.');
  }

  if (split_sql_query_1.hasValues(query)) {
    const queries = split_sql_query_1.default(query);

    if (queries.length > 1) {
      const results = await Promise.all(queries.map(async query => {
        const q = query.format(pgFormat);

        try {
          // TODO: pg-promise used: https://github.com/vitaly-t/pg-promise/blob/d92ecf0091b4a38b8972c5052662633549a1b462/lib/formatting.js#L284
          const results = await client.query(q);

          if (Array.isArray(results)) {
            if (results.length) {
              return results[results.length - 1].rows;
            } else {
              return [];
            }
          } else {
            return results.rows;
          }
        } catch (ex) {
          handleError(ex, query);
        }
      }));
      return results.length ? results[results.length - 1] : [];
    }
  }

  const q = query.format(pgFormat);

  try {
    // TODO: pg-promise used: https://github.com/vitaly-t/pg-promise/blob/d92ecf0091b4a38b8972c5052662633549a1b462/lib/formatting.js#L284
    const results = await client.query(q);

    if (Array.isArray(results)) {
      if (results.length) {
        return results[results.length - 1].rows;
      } else {
        return [];
      }
    } else {
      return results.rows;
    }
  } catch (ex) {
    handleError(ex, query);
  }
}

exports.executeOneStatement = executeOneStatement;

async function executeMultipleStatements(client, queries) {
  if (!Array.isArray(queries)) {
    throw new Error('Expected an array of queries.');
  }

  for (const el of queries) {
    if (!sql_1.isSqlQuery(el)) {
      throw new Error('Invalid query, you must use @databases/sql to create your queries.');
    }
  }

  if (queries.some(q => split_sql_query_1.hasValues(q))) {
    return await Promise.all(queries.map(async query => {
      const q = query.format(pgFormat);

      try {
        const results = await client.query(q);

        if (Array.isArray(results)) {
          throw new Error('When passing an array of statements to `db.query`, you must ensure that each entry in the array is a single Query.');
        } else {
          return results.rows;
        }
      } catch (ex) {
        handleError(ex, query);
      }
    }));
  }

  const query = sql_1.default.join(queries, `;`);
  const q = query.format(pgFormat);

  try {
    const results = await client.query(q); // TODO: assert that lengths match

    if (Array.isArray(results)) {
      if (results.length !== queries.length) {
        throw new Error('The number of queries in the array did not match the number of result sets. You cannot pass a query with multiple statements as an entry in an array.');
      }

      return results.map(r => r.rows);
    } else {
      if (1 !== queries.length) {
        throw new Error('The number of queries in the array did not match the number of result sets. You cannot pass a query with multiple statements as an entry in an array.');
      }

      return [results.rows];
    }
  } catch (ex) {
    handleError(ex, query);
  }
}

exports.executeMultipleStatements = executeMultipleStatements;

function handleError(ex, query) {
  if (pg_errors_1.isSQLError(ex) && ex.position) {
    const q = query.format(pgFormat);
    const position = parseInt(ex.position, 10);
    const match = /syntax error at or near \"([^\"\n]+)\"/.exec(ex.message) || /relation \"([^\"\n]+)\" does not exist/.exec(ex.message);
    let column = 0;
    let line = 1;

    for (let i = 0; i < position; i++) {
      if (q.text[i] === '\n') {
        line++;
        column = 0;
      } else {
        column++;
      }
    }

    const start = {
      line,
      column
    };
    let end;

    if (match) {
      end = {
        line,
        column: column + match[1].length
      };
    }

    ex.message += `\n\n${codeFrameColumns(q.text, {
      start,
      end
    })}\n`;
  }

  throw ex;
}