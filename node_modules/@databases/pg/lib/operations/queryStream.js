"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const stream_1 = require("stream");

const escape_identifier_1 = require("@databases/escape-identifier");

const sql_1 = require("@databases/sql");

const Cursor = require('pg-cursor');

const pgFormat = {
  escapeIdentifier: str => escape_identifier_1.escapePostgresIdentifier(str),
  formatValue: (value, index) => ({
    placeholder: `$${index + 1}`,
    value
  })
};

function queryNodeStream(client, query, options) {
  if (!sql_1.isSqlQuery(query)) {
    throw new Error('Invalid query, you must use @databases/sql to create your queries.');
  }

  const q = query.format(pgFormat);
  const c = new Cursor(q.text, q.values);
  let closed = false;
  let reading = false;
  const stream = new stream_1.Readable({ ...options,
    // defauâ€  to `false` in node 12 but true in node 14
    autoDestroy: true,
    objectMode: true,

    read(count) {
      if (reading) return;
      reading = true;

      const read = () => {
        c.read(count, (err, rows) => {
          if (err) {
            this.emit('error', err);
            return;
          }

          if (!rows.length) {
            closed = true;
            this.push(null);
            return;
          }

          let keepReading = true;

          for (const row of rows) {
            keepReading = keepReading && this.push(row);
          }

          if (keepReading) {
            read();
          } else {
            reading = false;
          }
        });
      };

      read();
    },

    destroy(err, callback) {
      if (closed) {
        callback(err);
        return;
      }

      closed = true;
      c.close(err2 => {
        callback(err !== null && err !== void 0 ? err : err2);
      });
    }

  });
  void client.query(c);
  return stream;
}

exports.queryNodeStream = queryNodeStream;

async function* queryStream(client, query, {
  batchSize = 16,
  signal
}) {
  if (!sql_1.isSqlQuery(query)) {
    throw new Error('Invalid query, you must use @databases/sql to create your queries.');
  }

  if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
    throw new Error('Aborted');
  }

  const q = query.format(pgFormat);
  const c = new Cursor(q.text, q.values);
  void client.query(c);

  const read = async () => {
    return await new Promise((resolve, reject) => {
      c.read(batchSize, (err, rows) => {
        if (err) reject(err);else resolve(rows);
      });
    });
  };

  let aborted = false;

  const abort = () => {
    if (aborted) return;
    aborted = true;
    c.close(() => {// ignore
    });
  };

  signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', abort);

  try {
    let nextPagePromise;
    let ended = false;

    while (!ended) {
      const page = await (nextPagePromise !== null && nextPagePromise !== void 0 ? nextPagePromise : read());

      if (page.length !== 0) {
        nextPagePromise = read();
        nextPagePromise.catch(ex => {// this error gets picked up later, so don't report the unhandled rejection
        });
        ended = false;
      } else {
        nextPagePromise = undefined;
        ended = true;
      }

      for (const row of page) {
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
          throw new Error('Aborted');
        }

        yield row;
      }
    }

    aborted = true;
  } finally {
    signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', abort);
    abort();
  }
}

exports.queryStream = queryStream;