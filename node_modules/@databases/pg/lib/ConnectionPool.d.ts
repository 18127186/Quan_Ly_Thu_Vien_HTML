/// <reference types="node" />
import { ConnectionOptions } from 'tls';
import { SQLQuery } from '@databases/sql';
import TransactionOptions from './types/TransactionOptions';
import Connection from './Connection';
import Transaction from './Transaction';
import AbortSignal from './types/AbortSignal';
import { Readable } from 'stream';
import { ConnectionPool as IConnectionPool, QueryableType } from './types/Queryable';
import TypeOverrides, { parseComposite, parseArray } from './TypeOverrides';
export default class ConnectionPool implements IConnectionPool {
    readonly type = QueryableType.ConnectionPool;
    readonly sql: import("@databases/sql").SQL;
    private readonly _schema;
    private readonly _config;
    private readonly _pool;
    private _hadSuccessfulConnection;
    private _disposed;
    private readonly _preparingOverrides;
    constructor(options: {
        types: TypeOverrides;
        [key: string]: any;
    }, { schema, hosts, ssl, handlers, }: {
        schema?: string | string[];
        hosts: {
            host: string;
            port?: number | undefined;
        }[];
        ssl: null | {
            allowFallback: boolean;
            ssl: ConnectionOptions;
        };
        handlers: {
            onError: (err: Error) => void;
        };
    });
    private _throwIfDisposed;
    private readonly _repairConnectionPool;
    private _getClient;
    private _withTypeResolver;
    registerTypeParser<T>(type: number | string, parser: (value: string) => T): Promise<(value: string) => T>;
    getTypeParser(type: number | string): Promise<(value: string) => any>;
    readonly parseComposite: typeof parseComposite;
    readonly parseArray: typeof parseArray;
    task<T>(fn: (connection: Connection) => Promise<T>): Promise<T>;
    tx<T>(fn: (connection: Transaction) => Promise<T>, transactionOptions?: TransactionOptions): Promise<T>;
    query(query: SQLQuery): Promise<any[]>;
    query(query: SQLQuery[]): Promise<any[][]>;
    queryNodeStream(query: SQLQuery, options?: {
        highWaterMark?: number;
    }): Readable;
    queryStream(query: SQLQuery, options?: {
        batchSize?: number;
        signal?: AbortSignal | undefined;
    }): AsyncGenerator<any, void, unknown>;
    dispose(): Promise<void>;
}
